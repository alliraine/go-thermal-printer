package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"sort"

	"golang.org/x/tools/go/packages"
)

func main() {
	outPath := filepath.Join("pkg", "template", "icon_registry_gen.go")

	cfg := &packages.Config{
		Mode: packages.NeedSyntax | packages.NeedFiles | packages.NeedName,
	}

	pkgs, err := packages.Load(cfg, "golang.org/x/exp/shiny/materialdesign/icons")
	if err != nil {
		log.Fatalf("failed to load icons package: %v", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		log.Fatalf("errors loading icons package")
	}
	if len(pkgs) == 0 {
		log.Fatalf("no packages found")
	}

	names := collectIconNames(pkgs[0].Syntax)
	sort.Strings(names)

	var buf bytes.Buffer
	buf.WriteString("// Code generated by go run internal/tools/genicons/main.go; DO NOT EDIT.\n")
	buf.WriteString("\n")
	buf.WriteString("package template\n")
	buf.WriteString("\n")
	buf.WriteString("import (\n")
	buf.WriteString("\tgioticons \"gio.tools/icons\"\n")
	buf.WriteString("\t\"gioui.org/widget\"\n")
	buf.WriteString("\ticonsraw \"golang.org/x/exp/shiny/materialdesign/icons\"\n")
	buf.WriteString(")\n\n")
	buf.WriteString("var iconData = map[string][]byte{\n")
	for _, name := range names {
		buf.WriteString(fmt.Sprintf("\t%q: iconsraw.%s,\n", name, name))
	}
	buf.WriteString("}\n")
	buf.WriteString("\n")
	buf.WriteString("var iconWidgets = map[string]*widget.Icon{\n")
	for _, name := range names {
		buf.WriteString(fmt.Sprintf("\t%q: gioticons.%s,\n", name, name))
	}
	buf.WriteString("}\n")

	if err := os.WriteFile(outPath, buf.Bytes(), 0o644); err != nil {
		log.Fatalf("failed to write %s: %v", outPath, err)
	}
}

func collectIconNames(files []*ast.File) []string {
	var names []string
	for _, file := range files {
		for _, decl := range file.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.VAR {
				continue
			}
			for _, spec := range gen.Specs {
				vs, ok := spec.(*ast.ValueSpec)
				if !ok {
					continue
				}
				for _, name := range vs.Names {
					if !name.IsExported() {
						continue
					}
					if name.Name == "" || name.Name == "init" {
						continue
					}
					names = append(names, name.Name)
				}
			}
		}
	}
	return unique(names)
}

func unique(in []string) []string {
	sort.Strings(in)
	out := in[:0]
	for i, v := range in {
		if i == 0 || v != in[i-1] {
			out = append(out, v)
		}
	}
	return out
}
